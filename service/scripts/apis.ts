/* eslint-disable no-nested-ternary */
import fs from 'fs';
import { parse, args, AsTree, Declaration, parseVisibleDecls } from '../tools/pet';

const modules: Record<string, { scoped: AsTree, decl: Declaration }> = {};
const decls: Record<string, { scoped: AsTree, decl: Declaration }> = {};

parse({
  plugins: {
    eachDeclaration(scoped, name, decl) {
      if (name === 'Module') {
        modules[scoped.name] = { scoped, decl };
      } else {
        decls[name] = { scoped, decl };
      }
    },
  },
});

function gen(): string {
  const imports: Record<string, Set<string>> = {};
  const types: Record<string, Declaration> = {};

  const output: Array<string> = [
    '// Auto generated by apis tool!',
    '/* eslint-disable @typescript-eslint/no-unused-vars */',
    '/* eslint-disable prefer-rest-params */',
  ];
  output.push('import { rpc } from \'../rpc\';');
  Object.entries(modules).forEach(([scopename, it]) => {
    const mname = scopename.split('/').pop();
    output.push(`export const ${mname} = {`);
    Object.entries(it.decl.methods || {}).forEach(([n, method]) => {
      output.push('  /**');
      for (const iterator of (method.comments || [])) {
        output.push(`   * ${iterator}`);
      }
      output.push('   */');

      let out = (method.output.type as any).getText();
      if (!/^Promise</.test(out)) {
        out = `Promise<${out}>`;
      }
      const args = method.inputs.slice(1);
      for (const iterator of args) {
        parseVisibleDecls(iterator, types);
      }
      parseVisibleDecls(method.output, types);
      output.push(`  ${n}(${args.map(e => `${e.name}${e.optional ? '?' : ''}: ${(e.type as any).getText()}`)
        .join(', ')}): ${out} {`);
      output.push(`    return rpc.request('${mname}.${n}', ...arguments);`);
      output.push('  },');
    });
    output.push('};\n');
  });

  for (const key of Object.keys(types)) {
    const ty = decls[key];
    if (!ty || ty.scoped.name === 'global') {
      continue;
    }
    const set = imports[ty.scoped.name] || (imports[ty.scoped.name] = new Set());
    set.add(key);
  }

  for (const [scoped, set] of Object.entries(imports).reverse()) {
    output.splice(3, 0, `import { ${[...set].join(', ')} } from '${scoped}';`);
  }

  return output.join('\n');
}

const src = gen() as any;
const outFileTs = args.out;
if (args.force || !fs.existsSync(outFileTs)) {
  fs.writeFileSync(outFileTs, src, 'utf-8');
  console.log(`已输出到文件 ${outFileTs}`);
} else {
  console.log(`文件已存在 ${outFileTs}`);
}

